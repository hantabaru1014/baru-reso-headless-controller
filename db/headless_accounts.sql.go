// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: headless_accounts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHeadlessAccount = `-- name: CreateHeadlessAccount :exec
INSERT INTO headless_accounts (resonite_id, credential, password, last_display_name, last_icon_url) VALUES ($1, $2, $3, $4, $5)
`

type CreateHeadlessAccountParams struct {
	ResoniteID      string
	Credential      string
	Password        string
	LastDisplayName pgtype.Text
	LastIconUrl     pgtype.Text
}

func (q *Queries) CreateHeadlessAccount(ctx context.Context, arg CreateHeadlessAccountParams) error {
	_, err := q.db.Exec(ctx, createHeadlessAccount,
		arg.ResoniteID,
		arg.Credential,
		arg.Password,
		arg.LastDisplayName,
		arg.LastIconUrl,
	)
	return err
}

const deleteHeadlessAccount = `-- name: DeleteHeadlessAccount :exec
DELETE FROM headless_accounts WHERE resonite_id = $1
`

func (q *Queries) DeleteHeadlessAccount(ctx context.Context, resoniteID string) error {
	_, err := q.db.Exec(ctx, deleteHeadlessAccount, resoniteID)
	return err
}

const getHeadlessAccount = `-- name: GetHeadlessAccount :one
SELECT resonite_id, credential, password, last_display_name, last_icon_url, created_at, updated_at FROM headless_accounts WHERE resonite_id = $1
`

func (q *Queries) GetHeadlessAccount(ctx context.Context, resoniteID string) (HeadlessAccount, error) {
	row := q.db.QueryRow(ctx, getHeadlessAccount, resoniteID)
	var i HeadlessAccount
	err := row.Scan(
		&i.ResoniteID,
		&i.Credential,
		&i.Password,
		&i.LastDisplayName,
		&i.LastIconUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHeadlessAccounts = `-- name: ListHeadlessAccounts :many
SELECT resonite_id, credential, password, last_display_name, last_icon_url, created_at, updated_at FROM headless_accounts ORDER BY resonite_id
`

func (q *Queries) ListHeadlessAccounts(ctx context.Context) ([]HeadlessAccount, error) {
	rows, err := q.db.Query(ctx, listHeadlessAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HeadlessAccount
	for rows.Next() {
		var i HeadlessAccount
		if err := rows.Scan(
			&i.ResoniteID,
			&i.Credential,
			&i.Password,
			&i.LastDisplayName,
			&i.LastIconUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountInfo = `-- name: UpdateAccountInfo :exec
UPDATE headless_accounts SET last_display_name = $2, last_icon_url = $3 WHERE resonite_id = $1
`

type UpdateAccountInfoParams struct {
	ResoniteID      string
	LastDisplayName pgtype.Text
	LastIconUrl     pgtype.Text
}

func (q *Queries) UpdateAccountInfo(ctx context.Context, arg UpdateAccountInfoParams) error {
	_, err := q.db.Exec(ctx, updateAccountInfo, arg.ResoniteID, arg.LastDisplayName, arg.LastIconUrl)
	return err
}

const updateHeadlessAccountCredentials = `-- name: UpdateHeadlessAccountCredentials :exec
UPDATE headless_accounts SET credential = $2, password = $3 WHERE resonite_id = $1
`

type UpdateHeadlessAccountCredentialsParams struct {
	ResoniteID string
	Credential string
	Password   string
}

func (q *Queries) UpdateHeadlessAccountCredentials(ctx context.Context, arg UpdateHeadlessAccountCredentialsParams) error {
	_, err := q.db.Exec(ctx, updateHeadlessAccountCredentials, arg.ResoniteID, arg.Credential, arg.Password)
	return err
}
